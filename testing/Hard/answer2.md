# Решение

Разберемся с алгоритмом пошагово:

1. **Инициализация переменных:**
   - Мы начинаем с инициализации переменных `left` и `right`. Переменная `left` указывает на начало массива (индекс 0), а переменная `right` указывает на его конец (индекс `nums.length - 1`).

2. **Проверка граничных случаев:**
   - Мы сначала проверяем, не пропущено ли число 1 в самом начале массива (`nums[0] !== 1`). Если это так, мы сразу возвращаем 1 как пропущенное число.
   - Затем мы проверяем, не пропущено ли число n (где n - количество элементов в массиве) в конце массива (`nums[right] !== nums.length + 1`). Если это так, мы сразу возвращаем `nums.length + 1` как пропущенное число.

3. **Бинарный поиск:**
   - Мы используем бинарный поиск для нахождения пропущенного числа. В каждой итерации мы вычисляем средний индекс `mid` между `left` и `right`.
   - Если число в середине массива равно ожидаемому числу (то есть `nums[mid] === mid + 1`), это означает, что все числа до `mid` на своем месте, и пропущенное число находится правее. Таким образом, мы обновляем `left = mid + 1`.
   - Если число в середине массива не равно ожидаемому числу (то есть `nums[mid] !== mid + 1`), это означает, что пропущенное число находится левее. Мы обновляем `right = mid - 1`.

4. **Нахождение пропущенного числа:**
   - Процесс бинарного поиска продолжается, пока `left <= right`.
   - После завершения цикла `right` указывает на индекс, где находится пропущенное число.
   - Ожидаемое пропущенное число равно `nums[right] + 1`, так как в отсортированном массиве пропущенное число находится между `nums[right]` и `nums[right + 1]`.

5. **Возврат результата:**
   - Мы возвращаем ожидаемое пропущенное число.

Таким образом, алгоритм бинарного поиска позволяет эффективно находить пропущенное число в отсортированном массиве за время O(log n), где n - количество элементов в массиве.

```js
function missingNumber(nums) {
    let left = 0;
    let right = nums.length - 1;
    
    // Если первый элемент не равен 1, то пропущено число 1
    if (nums[0] !== 1) return 1;
    
    // Если последний элемент не равен длине массива + 1, то пропущено последнее число
    if (nums[right] !== nums.length + 1) return nums.length + 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        
        // Если число в середине массива равно ожидаемому числу, продолжаем поиск справа
        if (nums[mid] === mid + 1) {
            left = mid + 1;
        } 
        // Иначе пропущенное число находится левее
        else {
            right = mid - 1;
        }
    }
    
    // После завершения цикла right указывает на индекс пропущенного числа
    // Ожидаемое пропущенное число - nums[right] + 1
    return nums[right] + 1;
}
```

# Решение 2 (Решение одного из студентов)

```js
function missingNumber(nums) {
  let left = 0;
  let right = nums.length - 1;

  while(left < right) {
    const midIndex = Math.floor((left + right) / 2)
    const value = nums[midIndex- 1] ;

    if (midIndex === value) {
      left = midIndex + 1;
    } else {
      right = midIndex - 1;
    }
  }

  return left
}
```